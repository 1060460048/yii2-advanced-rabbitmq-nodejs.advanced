<h1>
    Stomp Теория
</h1>
<pre>
    установить плагин stomp для rabbitmq:
    ubuntu:
    http://www.rabbitmq.com/stomp.html
    sudo rabbitmq-plugins enable rabbitmq_stomp
    sudo rabbitmq-plugins enable rabbitmq_web_stomp
    перезапустить сервер rabbitmq:
    sudo service rabbitmq-server restart
    windows:
    cd "C:\Program Files (x86)\RabbitMQ Server\rabbitmq_server-3.2.2\sbin"
    rabbitmq-plugins list -e
    rabbitmq-plugins enable rabbitmq_stomp
    rabbitmq-plugins disable rabbitmq_stomp
    rabbitmq-plugins list -e
    rabbitmq-plugins enable rabbitmq_management
    http://localhost:15672/
    guest/guest
    rabbitmq-service.bat stop
    rabbitmq-service.bat start
</pre>
<p>
    amqp - на серверной стороне обрабатывает сообщения и если надо, то возвращает их через react/stomp в sockjs-client
</p>
<pre>
    Использование Apache ActiveMQ позволило нам направлять сообщения от клиентов
не сразу в БД, а пропускать их через очередь сообщений.
В результате мы имеем:
- более быстрое выполнение puppet-процесса на клиенте, потому что при попытке отправки отчёта
на сервер он сразу получает «ОК» (поставить сообщение в очередь проще, чем записать его в базу);
- снижение нагрузки на MySQL (процесс puppet queue записывает данные в базу асинхронно)

Поскольку мы ожидаем самые разные события, из различных источников, направленные различным клиентам, потребуется надежная система управления потоками сообщений на сервере. Существует простой, но элегантный протокол STOMP ( stomp.codehaus.org/ ). В API всего несколько команд (SEND, SUBSCRIBE, UNSUBSCRIBE, BEGIN, COMMIT, ABORT, ACK, DISCONNECT) посредством которых общаются STOMP клиенты и STOMP брокеры

— генерация thumbnails
— сбор статистики
— рассылка писем/сообщений
— удаление данных с таблиц
— индексация данных
— импорт данных в базу

ActiveMQ — это открытая реализация message broker системы. Преимущество данной системы это высокая производительность, открытость и возможность реализации клиентов на любых языках. ActiveMQ в данный момент поддерживает следующее протоколы:
— OpenWire (собственный бинарный протокол);
— Stomp;
— REST;
— WS Notification;
— XMPP.

В ActiveMQ существует утилита, в которой вы сможете смотреть статистику отосланных сообщений, список очередей и даже отослать сообщение, очень удобно использовать для отладки. Находиться она по адресу http://0.0.0.0:8161/admin/.

Очевидно, что на каждого клиента нам нужен один постоянно работающий серверный push-процесс, который называется Comet (Комета). Это накладно с точки зрения использования памяти сервера, но альтернатива этому: постоянные запросы к серверу — на порядок хуже, медленнее и тяжелее. Правда есть еще один хороший вариант — работать напрямую с сокетами, но это отдельная тема.

Для очередей необходимо использовать сторонние менеджеры. В нашем случае хорошо себя проявил Active MQ.
Работа с кометами и отправляемыми на сервер запросами должна осуществляться легковесными скриптами, без полной инициализации фреймворка, коннектов к базе и других излишеств

STOMP — протокол обмена сообщениями, созданный предельно простым. Основан на фреймах по образцу HTTP. Фрейм состоит из команды, необязательных заголовков и необязательного тела.

Например, приложение Stock Portfolio может рассылать котировки, клиент пошлет фрейм SUBSCRIBE, где заголовок «destination» показывает на что конкретно он подписывается:
SUBSCRIBE
id:sub-1
destination:/topic/price.stock.*
Как только котировки акций становятся доступными, сервер отправляет фрейм MESSAGE с соответствующим «destination» и идентификатором подписки, а также заголовок «content-type» и тело:
MESSAGE
subscription:sub-1
message-id:wm2si1tj-4
content-type: application/json
destination:/topic/stocks.PRICE.STOCK.NASDAQ.EMC
{\"ticker\":\"EMC\",\"price\":24.19}

Загрузка портфеля позиций
Клиент запрашивает портфель позиций
Приложение обрабатывает запрос путем загрузки и возврата данных для подписки
Message-broker не участвует в этом взаимодействии
Подписка на котировки акций
Клиент отправляет запрос на подписку
Приложение передает сообщение брокеру
Message-broker передает сообщение всем подписанным клиентам
Получение котировок акций
QuoteService посылает брокеру сообщение с котировками акций
Message-broker передает сообщение всем подписанным клиентам
Проведение сделки
Клиент отправляет торговый запрос
Приложение не обрабатывает его, все сделки проходят через TradeService
Message-broker не участвует в этом взаимодействии
Получение обновления позиций
TradeService отправляет сообщение об обновлении позицию в очередь брокера
Message-broker отправляет обновление позиций клиенту
Отправка сообщений определенному пользователю

Легко понять, как можно разослать сообщения всем подписанным клиентам — просто послать сообщение в канал. Чуть сложнее дело обстоит с отсылкой сообщения конкретному клиенту. Например, вы поймали исключение и хотите отправить сообщение об ошибке. Или вы получили подтверждение о завершении сделки и хотите обрадовать пользователя.
В традиционных приложениях для обмена сообщениями эта задача обычно решается созданием временной очереди и задания заголовка «reply-to» во всех сообщениях, подразумевающих ответ. Это работает, но выглядит довольно громоздким. Клиент не должен забывать выставлять необходимые заголовки на всех применяемых сообщениях и серверному приложению может потребоваться отслеживать их. Иногда такая информация может быть недоступна (например, если используется HTTP POST вместо обмена сообщениями).
Для поддержки этого требования, мы отправляем уникальный суффикс очереди каждому подключенному клиенту. Суффикс затем может быть добавлен к идентификатору для создания уникального имени очереди
</pre>